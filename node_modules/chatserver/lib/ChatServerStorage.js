var DbPool=require('./db_pool');

exports.createStorage = function(opts) {
	return new Storage(opts);
}

function Storage(opts) {
	this.ttl_msg=opts.ttl_msg || 3600;
	this.ttl_user=opts.ttl_user || 3600;
	this.pub=DbPool.createRedisClient(opts);
	this.sub=DbPool.createRedisClient(opts);
	this.storage=DbPool.createRedisClient(opts);
	this.channel=undefined;
	this.userInfo=undefined;
}
var sendSystemMSG=function(msg, channel, callback){ return callback(null,{
	"command": "messages",
	"data": [{
		"author": "system",
		"channel": channel,
		"text": msg,
		"timestamp": new Date().getTime()
	}]
}) }

Storage.prototype=(function(){ return {
	'subscribe': function(data, callback){
		data=data || [];
		var self=this;
		if(self.channel) self.sub.unsubscribe();
		// set event only once
		else self.sub.on("message", function(pattern, key){
			self.storage.hgetall(key, function(e, obj){ return callback(null,{
				"command": "messages",
				"data": [{
					"author": obj.author,
					"channel": obj.channel,
					"text": obj.text,
					"timestamp": new Date().getTime()
				}]
			}) });
		});
		data.forEach(function(item){
			item=item || {};
			// subscribed
			if(self.channel==item.channel)
				return callback(null,{"status":"ACK"});
			self.channel=item.channel;
			self.sub.subscribe(item.channel);
		});
		self.storage.keys(self.channel+"*",function(e, keys){
			var messages=[];
			keys.forEach(function(key, index, array){
				self.storage.hgetall(key, function(e, obj){
					messages.push({
						"author": obj.author,
						"channel": obj.channel,
						"text": obj.text,
						"timestamp": new Date().getTime()
					});
					if(index === array.length - 1) {
						sendSystemMSG("Welcome to a new channel",self.channel,callback)
						return callback(null,{
							"command": "messages",
							"data": messages
						});
					}
				});
			});
		});
	},
	'sendMsg': function(data, callback) {
		data=data || [];
		var self=this;
		if(!self.userInfo) return sendSystemMSG("You have to set your name",self.channel,callback);
		if(!self.channel) return sendSystemMSG("You have to join to the channel",self.channel,callback);
		data.forEach(function(item){
			item=item || {};
			self.storage.incr("messageNextId", function(e, id){
				var key=item.channel+"_messages:" + id;
				self.storage.hmset(key, { "author": item.author, "text": item.text, "channel": item.channel }, function(e, r){
					self.pub.publish(item.channel, key);
				});
				self.storage.expire(key,self.ttl_msg,function(e, r){});
			});
		});
		return callback(null,{"status":"ACK"});
	},
	'setName': function(data, callback){
		data=data || [];
		var self=this;
		data.forEach(function(item){
			// the name was selected
			if(typeof(self.userInfo)=="object" && self.userInfo.name==item.author)
				return callback(null,{"status":"ACK"});
			var key="auth_"+item.author;
			self.storage.setnx(key,-1,function(e,r){
				if(!r) return sendSystemMSG("This name has been locked. Try another name.",self.channel,callback);
				self.storage.incr("authNextId", function(e, id){ self.storage.set(key,id,function(e, r){
					// free the previous name
					if(self.userInfo) self.storage.del("auth_"+self.userInfo.name,function(e, r){});
					self.userInfo={"id": id,"name": item.author};
					self.storage.expire(key,self.ttl_user,function(e, r){});
					return sendSystemMSG("greetings, "+item.author+"!",self.channel,callback);
				}) });
			});
		});
	}
} })();