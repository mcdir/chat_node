var Util = require('util');
var Events = require('events');
var WebSocketServer=require('websocket').server;
var http=require('http');

exports.createServer = function() {
	return new Server(arguments[0],arguments[1]);
}

Util.inherits(Server, Events.EventEmitter);

function Server( /* options, listener */ ) {
	if (!(this instanceof Server)) return new Server(arguments[0], arguments[1]);
	Events.EventEmitter.call(this);

	var self = this;
	var options;

	if (typeof arguments[0] == 'function') {
		options = {};
		self.on('connection', arguments[0]);
	} else {
		options = arguments[0] || {};

		if (typeof arguments[1] == 'function') {
			self.on('connection', arguments[1]);
		}
	}
	self.connectionCount = 0;
	self.server=http.createServer(function(request, response) {
		console.log((new Date()) + ' Received request for ' + request.url);
		response.writeHead(404);
		response.end();
	});
	var wsServer=new WebSocketServer({
		'httpServer': self.server,
		'autoAcceptConnections': false
	});
	wsServer.on('request', function(request) {
		var connection = request.accept('', request.origin);
		var id=createUID();
		connection.send(connection.id=id);
		++self.connectionCount;
		self.emit('connection');
		var storage=options.createStorage();
		var oResponseBuilder=options.createResponseBuilder(storage);
		connection.on('message',function(message){
			if(message.type !== 'utf8')
				return;
			var oMsg=JSON.parse(message.utf8Data);
			if(oMsg.id===null)
				return;
			oResponseBuilder.build(oMsg,function(err,data){
				data.id=id;
				if(err) console.log(JSON.stringify(err));
				connection.send(err?'':JSON.stringify(data));
			});
		});
		connection.on('close', function(reasonCode, description) {
			log((new Date()) + ' Peer ' + connection.remoteAddress + ' disconnected.');
		});
		connection.emit( 'open', id );
	});
	self.server.on('error', function(e) {
		if (e.code == 'EADDRINUSE') {
			log("server error, address already in use: " + e);
		} else {
			log("server error: " + e);
		}
	});
	self.server.on('close', function() {
		log("ChatServer closing after handling " + self.connectionCount + " connections");
	});
}
Server.prototype.listen=function (port,host,callback) {
	var self=this;
	log('ChatServer binding to port ' + port + ' on ' + (host || 'all IPs') + "...");
	this.server.listen(port,host,function(){
		log("successfully bound!");
		if(typeof(callback)=='function')
			callback.call(self);
	});
}

function createUID() {
	var random, value;
	var id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function ( c ) {
		random = Math.random()*16|0;
		value = ( c === 'x' ) ? random : (random&0x3|0x8);
		return value.toString(16);
	});
	return id;
}

function log(message) {
	var t = (new Date()).toISOString();
	console.log(t + ' - ' + message);
}